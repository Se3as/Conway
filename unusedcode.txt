    xor ecx, ecx ; ecx queda = 0 / col = 0


row_loop:
    cmp ecx, 3 ; un cmp(compare) para verificar si alcanzo la fila final 
    jge printer ; un jge(jump if greater o equal) para saber si termino para imprimir

    xor edx, edx ; col = 0 si la row cambia reseteo mi fila

col_loop:
    cmp edx, 3
    jge refresher ; si la col alcanza su final se salta a refrescar y luego a aumentar col

    ; si la condicion no ocurre...

    ; busco recorrer un arreglo, pero en ensamblador son listas que visualizo como matrices, dando saltos entre seciones
    ; para moverme en el aquivalente a arr[i][j], debo hacer arr[i * 3 + j]
    ; que representa saltos de 10 para moverme entre las secciones planas de un arreglo

    mov eax, ecx ; eax = i / mi indice de fila nuevo
    imul eax, eax, 3 ; eax = i * 10
    add eax, edx ; eax = i * 3 + j

    mov byte [grid + eax], 1 ; guardo el numero 1 en la posicion arr[i][j] calculada

    inc edx ; incremento mi columna, similar a decir arr[i + 1][j]
    jmp col_loop

refresher:
    inc ecx
    jmp row_loop















section .data
    
    hop db 10, 0
    one db '1', 0
    zero db '0', 0
    blanc db ' ', 0

    grid db 1, 0 ,1, 0, 1
            db 0, 0, 0, 1, 0
            db 0, 1, 0, 0, 0
            db 1, 1, 1, 1, 1
            db 0, 1, 1, 0, 1

section .text
    global _start


_start:
    call printer

    mov eax, 4      
    mov ebx, 1       
    mov ecx, hop
    mov edx, 1
    int 0x80

    ;call neighbours


    call ejected


printer:
    xor esi, esi

print_row:
    cmp esi, 5
    jge printed

    xor edi, edi

print_col:
    cmp edi, 5
    jge next_line

    ; indice del arr[][]
    mov ebx, esi
    imul ebx, 5
    add ebx, edi

    ; analizo si es 0 y salto o 1 e imprimo
    mov al, [grid + ebx]
    cmp al, 0
    je print_zero

    ; era 1
    mov eax, 4      
    mov ebx, 1      
    mov ecx, one
    mov edx, 1
    int 0x80

    ; Imprimir espacio
    mov eax, 4
    mov ebx, 1
    mov ecx, blanc
    mov edx, 1
    int 0x80


    jmp advance_col


print_zero:
    mov eax, 4      
    mov ebx, 1     
    mov ecx, zero
    mov edx, 1
    int 0x80

    ; Imprimir espacio
    mov eax, 4
    mov ebx, 1
    mov ecx, blanc
    mov edx, 1
    int 0x80


advance_col:
    inc edi
    jmp print_col


next_line:
    mov eax, 4      
    mov ebx, 1       
    mov ecx, hop
    mov edx, 1
    int 0x80

    inc esi
    jmp print_row

printed:
    ret




neighbours:
    



ejected:
    mov eax, 1
    xor ebx, ebx
    int 0x80